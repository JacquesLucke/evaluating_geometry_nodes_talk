<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Evaluating Geometry Nodes</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/black.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/my_theme.css" />

    <!-- <script src="https://js.polli.live/main.js"></script> -->
    <script src="http://localhost:8080/main.js"></script>

    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js"
      integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.35.0/plotly.min.js"
      integrity="sha512-L205fVN73b8Ft9dbuwTVGFb4FHVSOPpCLMQzcHa4r0+CuUswxzK/JRW7glZrpC+bO3Yaka0DYYDmtlhVbmnX+g=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>

    <style>
      .reveal h1,
      .reveal h2,
      .reveal h3,
      .reveal h4,
      .reveal h5,
      .reveal h6 {
        text-transform: none;
      }

      .function_name {
        color: rgb(219, 166, 103);
      }

      .fragment.blur {
        filter: blur(0.2em);
      }

      .fragment.blur.visible {
        filter: none;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section><h2>Evaluating Geometry Nodes</h2></section>
        <section>
          <div
            style="display: grid; grid-template-columns: 2fr 3fr; height: 100%"
          >
            <div>
              <img
                class="polli-live-qr-code"
                style="
                  image-rendering: pixelated;
                  margin: 0;
                  width: 100%;
                  background-color: white;
                  border: 0.5em solid transparent;
                  border-radius: 0.5em;
                  box-sizing: border-box;
                "
              />
            </div>
            <div>
              Join the interactive part!
              <div
                class="polli-live-choice"
                id="join-interactivity"
                style="width: 100%"
              >
                <option>I'm in</option>
                <option>Wait</option>
              </div>
            </div>
          </div>
        </section>
        <section>
          <h2>Topics</h2>
          <p>Get Started</p>
          <p>Lazy Evaluation</p>
          <p>Array Processing</p>
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * Start with showing some simpler evaluation methods to set the scene.
              * These are also methods that make sense when just starting out to build a new node system.
            * Then we have a look at how the geometry nodes graph is processed and how it is evaluated at a high level.
            * Lastly, we have a look at how math functions are evaluated as part of field evaluation
          </aside>
        </section>
        <section>
          <h2>About Me</h2>
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * Started building node systems for Blender about 10 years ago when I was still in school (Animation Nodes).
            * Hired by Blender after my studies in 2018 and am working remotely from the Berlin area nowadays.
            * Lead developer for geometry nodes since the beginning in 2020.
            * Best thing about the job is seeing all the cool stuff people make with the tools Hans and I implement in our living rooms, with the help of many others of course.
              * I'm thankful for everyone who shares their early experiments especially when testing new features. It's super helpful and motivating.
          </aside>
        </section>
        <section>
          <h2>What's your background?</h2>
          <div class="polli-live-continuum" id="what-is-your-background-poll">
            <option>Artistic</option>
            <option>Both</option>
            <option>Technical</option>
          </div>
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * I'm also curious about the background of the audience.
            * Personally, I'm more on the technical side, but I'm always most impressed by people who combine technical and artistic skills.
              * Like Simon Thommes who is a great help in the geometry nodes team bridging the gap between the two worlds.
          </aside>
        </section>
        <section>
          <h2>Get Started</h2>
          <img src="images/get_started.png" />
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * The image shows a simple node tree that I'll use as starting point to discuss some of the core concepts.
            * Using it I'll explain some simple graph evaluation strategies.
          </aside>
        </section>
        <section>
          <h2>Toposort</h2>
          <img src="images/toposort.png" />
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * The simplest mechanims is to simply sort the nodes topologically.
              * That means that we order the nodes in a way that nodes always come after everything they depend on.
              * The ordering is always possible unless there are cycles in the node tree, but none of the other methods work in that case either.
            * Once sorted, we can just evaluate the nodes one after the other making sure we pass data correctly between them.
            * This general approach was used by Animation Nodes, with the addition that after sorting a Python script is generated that executes the nodes.
            * While very simple, this approach in its pure form has some significant limitations like:
              * All nodes are always evaluated, even if they are not needed.
              * It's hard to parallelize the evaluation.
            * While just using toposort is not great for evaluation, it's still a very important concept that's used in many places in Blender when analysing node trees.
          </aside>
        </section>
        <section>
          <h2>Two-Pass Evaluation</h2>
          <img src="images/two_pass.png" />
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * A way to remedy the first problem is to process nodes in two passes.
              * In the first pass, we figure out which nodes are needed for the final result.
              * In the second pass, we only evaluate the nodes that are needed.
            * In the example here that means that we detect that the second Add node is not needed and it can be ignored.
            * In this case it's obvious because the output of the node is not used at all.
            * However, some more complex cases can be handled with this approach too.
              * The dependency graph evaluation uses a separate pass to first determine when objects are visible in the case of animated visibility.
              * Switch nodes with simple conditions could be handled this way too.
          </aside>
        </section>
        <section>
          <h2>Push vs. Pull</h2>
          <img src="images/switch_domain_size.png" />
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * So far we've only looked at what I'd call push based evaluation.
              * That means that we first determine all nodes to evaluate and then start evaluating them at the beginning.
            * That can be good enough for many kinds of node systems.
              * It's used by shader (eevee and cycles) and compositor evaluation.
            * It's far from ideal for geometry nodes:
              * The problem is that we just can't determine which nodes have to be evaluated before having evaluated potentially large parts of the node tree already.
              * Also, the condition of switch nodes may depend on the result of other switch nodes.
              * Users have to be able to trust that when a switch node disables part of the node tree, that those nodes really won't be evaluated.
            * A solution is to use what I call a pull based evaluation system.
              * No preprocessing is necessary to determine which nodes are necessary.
              * That means, the evaluation does not start at the input, but at the output.
              * When a node is evaluated, it first requests the missing inputs from the nodes that come before.
              * Importantly, it does not have to request all of them at the same time.
                * For example, the switch node first only requests the condition input.
                * Once that comes back, it can request one of the remaining inputs.
                * Solving this generically comes with some extra complexity, especially if multi-threaded evaluation has to be supported too.
                * Next I'll present the internal evaluation system we actually use for geometry nodes.
          </aside>
        </section>
        <section>
          <h2>Lazy Function API</h2>
          <ul style="list-style-type: none">
            <li><code class="function_name">get_or_request_input</code></li>
            <li><code class="function_name">set_output</code></li>
            <li>
              <code
                class="function_name fragment custom blur"
                data-fragment-index="1"
                >set_input_unused</code
              >
            </li>
            <li>
              <code
                class="function_name fragment custom blur"
                data-fragment-index="1"
                >get_output_usage</code
              >
            </li>
          </ul>
          <!-- prettier-ignore -->
          <aside class="notes" data-markdown>
            * At the core of our lazy evaluation system is the `LazyFunction` class.
            * All nodes are implemented as lazy-function in Geometry Nodes.
              * That may not be immediately obvious when working on nodes though.
              * That's because most nodes use a more high-level API that hides away the lazyness aspect.
              * More special nodes like the different kinds of Switch nodes are implemented directly as `LazyFunction` though.
          </aside>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      const standard_width = 960;
      const standard_height = 700;
      const graphs_container_ids = [];

      async function make_graph(
        source_file_path,
        container_id,
        x_name,
        y_name,
        filter_x_fn = (v) => true
      ) {
        const container_elem = document.getElementById(container_id);
        if (!container_elem) {
          console.error("Container not found:", container_id);
          return;
        }

        let csv_data = await d3.csv(
          "analysis/grain_size_results.csv",
          d3.autoType
        );
        csv_data = csv_data.filter((v) => filter_x_fn(v[x_name]));
        graphs_container_ids.push(container_id);

        container_elem.style.width = "100%";
        container_elem.style.aspectRatio = "2 / 1";
        container_elem.style.display = "flex";
        container_elem.style.justifyContent = "center";
        container_elem.style.alignItems = "center";

        const trace1 = {
          x: csv_data.map((v) => v[x_name]),
          y: csv_data.map((v) => v[y_name]),
          type: "lines+markers",
          line: {
            color: "rgb(219, 166, 103)",
          },
        };

        const data = [trace1];

        const tick_font_size = 36;
        const title_font_size = 24;

        const layout = {
          paper_bgcolor: "transparent",
          plot_bgcolor: "transparent",
          showlegend: false,
          xaxis: {
            gridcolor: "#222",
            tickcolor: "transparent",
            tickformat: ",.0f",
            nticks: 5,
            tickfont: {
              color: "white",
              size: tick_font_size,
            },
            title: {
              text: x_name,
              font: {
                size: title_font_size,
                color: "white",
              },
              standoff: 20,
            },
          },
          yaxis: {
            gridcolor: "#222",
            tickcolor: "transparent",
            tickformat: ",.0f",
            nticks: 5,
            tickfont: {
              color: "white",
              size: tick_font_size,
            },
            title: {
              text: y_name,
              font: {
                size: title_font_size,
                color: "white",
              },
              standoff: 10,
            },
          },
          margin: {
            l: 110,
            r: 110,
            b: 100,
            t: 0,
            pad: 0,
          },
          scrollZoom: false,
          dragmode: false,
        };

        Plotly.newPlot(container_id, data, layout, {
          displayModeBar: false,
          responsive: false,
        });
      }

      // make_graph(
      //   "analysis/grain_size_results.csv",
      //   "first-plot",
      //   "Grain Size",
      //   "Time (s)",
      //   (x) => x < 10000
      // );
      // make_graph(
      //   "analysis/grain_size_results.csv",
      //   "second-plot",
      //   "Grain Size",
      //   "Time (s)",
      //   (x) => true
      // );

      polli_live.initialize({
        width: standard_width,
        height: standard_height,
      });
      Reveal.initialize({
        hash: true,
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
      Reveal.addEventListener("slidechanged", function (event) {
        const currentSlide = event.currentSlide;
        if (!currentSlide) {
          return;
        }
        for (const container_id of graphs_container_ids) {
          const element = currentSlide.querySelector("#" + container_id);
          if (element) {
            Plotly.Plots.resize(element);
          }
        }
      });
    </script>
  </body>
</html>
